# 设计模式

## 六大原则

1. 开闭
2. 里氏代换
3. 依赖倒装
4. 接口隔离
5. 迪米特（最少知道）
6. 合成复用

## 常见设计模式

1. 创建型： 提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
    1. 工厂!
        - spring中的BeanFactory，通过getBean来获取bean对象
        - 何时用：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
    2. 单例!
        - spring中的bean默认使用单例
        - 何时用：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

    3. 建造者!
        0. 发现类中有好几个构造函数，参数也有十几个，为了减少过多的构造函数以及入参，采用建造者模式。
        1. 解决什么问题：建造者模式（Builder Pattern）是一种创建型设计模式，主要用于构建复杂对象。它将对象的构建过程与表示分离，使得同样的构建过程可以创建不同的表示。通过创建Builder对象，设置属性，调用build方法返回外部类的对象。
        2. 优点
            - 更好的控制对象的构建过程：可以一步一步地构建对象，并且可以灵活地控制每一步的构建过程。
            - 代码更清晰：将复杂对象的构建过程封装在一个独立的Builder类中，使得主类的代码更加简洁。
            - 易于扩展：可以很容易地添加新的构建步骤或修改现有的构建步骤，而不影响使用该模式的客户端代码。
            - 避免构造函数过多：当一个类有很多参数时，使用Builder模式可以避免构造函数参数过多的问题。
        3. 缺点
            - 增加代码复杂度：需要额外创建Builder类，增加了代码量。
            - 不适合简单对象：对于简单对象，使用Builder模式可能显得过于复杂，不如直接使用构造函数或工厂模式。
        4. 适用场景
            - 需要构建的对象包含多个可选参数或步骤。
            - 需要创建的对象是不可变对象。
            - 需要创建的对象具有复杂的内部结构或依赖关系。
        5. 代码解析：采用静态内部类的方式有以下几个原因：封装性：静态内部类可以访问外部类的私有成员，这使得它可以更好地封装对象的构建过程，同时保持外部类的封装性。避免外部类实例化：静态内部类不需要外部类的实例即可创建，这使得构建器模式更加灵活，不需要先创建外部类的实例。清晰的构建过程：将构建过程封装在静态内部类中，使得代码更加清晰，易于理解和维护。线程安全：静态内部类的实例在第一次使用时才会被创建，这种懒加载机制可以确保线程安全。减少内存开销：静态内部类不会持有外部类的引用，避免了不必要的内存开销。 
    4. 原型
        - spring中scope="prototype"，每次获取的是通过克隆生成的新实例
        - 何时用：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
    5. 简单工厂
    6. 抽象工厂

2. 结构型：关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。
    1. 代理!
        - springAOP，jdk和cglib动态代理
        - 何时用：为其他对象提供一种代理以控制对这个对象的访问。
    2. 适配器
        - springAOP中的AdvisorAdapter
        - 何时用：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
    3. 过滤器
    4. 外观
    5. 桥接
    6. 装饰器
    7. 组合
    8. 享元

3. 行为型：关注对象之间的通信。
    1. 策略
        - spring中提供了InstantiationStrategy
        - 何时用：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

    2. 模板
        - spring中的AbstractPlatFormTransactionManager事务管理器
        - 何时用：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

    3. 观察者
        - spring事件驱动模型中的三种角色
        - 何时用：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

    4. 责任链
        - dispatcherServlet中的都doDispatch（）方法中获取与请求匹配的处理器HandlerExecutionChain，this.getHandler()方法的处理使用到了责任链模式
        - 何时用：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

    5. 命令
    6. 解释器
    7. 迭代器
    8. 中介者
    9. 备忘录
    10. 状态
    11. 空对象
    12. 访问者

