# Java基础

## 基础概念与常识

1. Java特点
    - 简单易学
    - 面向对象（封装、继承、多态
    - 平台无关

2. JavaSE与JavaEE：标准版与企业版
    - JavaEE包含JavaSE

3. JVM与JDK与JRE
    - 只要满足JVM规范，每个个体都可以开发自己专属的JVM
    - JRE包含JVM及基础类库
    - JDK包含JRE及开发调试工具
    - 从JDK9以后，不再区分JDK与JRE，取而代之是模块系统（JDK 被重新组织成 94 个模块）+ jlink 工具；从 JDK 11 开始，Oracle 不再提供单独的 JRE 下载。

4. 字节码：JVM可理解的代码，扩展名为.class的文件，只面向虚拟机。（.java经过javac编译为.class，热点代码通过JIT（Just in Time Compilation）编译器编译为机器码，其他代码经解释器逐行解释为机器码，可被机器理解的代码。

5. Oracle JDK与Open JDK：Open JDK为开源

## 基本语法

1. 注释：单行、多行、文档注释
2. 标识符与关键字：标识符就是一个名字；关键字是Java语言已经赋予其特殊含义、只能用于特定地方的特殊标识符。
    - 访问控制
    - 类、方法、变量修饰符
    - 程序控制
    - 错误处理
    - 包相关
    - 基本类型
    - 变量引用
    - 保留字
3. 自增自减运算符：符号在前就先加/减，符号在后就后加/减。
4. 移位运算符：移位操作中，被操作的数据被视为二进制数，移位就是将其向左或向右移动若干位的运算。
    1. 使用移位运算符的主要原因：
        - 高效：移位运算符直接对应于处理器的移位指令。现代处理器具有专门的硬件指令来执行这些移位操作，这些指令通常在一个时钟周期内完成。相比之下，乘法和除法等算术运算在硬件层面上需要更多的时钟周期来完成。
        - 节省内存：通过移位操作，可以使用一个整数（如 int 或 long）来存储多个布尔值或标志位，从而节省内存。
    2. Java 中有三种移位运算符：
        - << :左移运算符，向左移若干位，高位丢弃，低位补零。x << n,相当于 x 乘以 2 的 n 次方(不溢出的情况下)。
        - \>> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。x >> n,相当于 x 除以 2 的 n 次方。
        - \>>> :无符号右移，忽略符号位，空位都以 0 补齐。

## 基本数据类型

1. 8种基本数据类型（位数，字节，默认值）(符号位，0表示正数，1表示负数)
    1. 6种数字类型
        1. 4种整数型：byte（8，1，0）、short（16，2，0）、int（32，4，0）、long（64，8，0L）
        2. 2种浮点型：float（32，4，0f）、double（64，8，0d）
    2. 1种字符类型：char（16，2，'u0000'）
    3. 一种布尔型：boolean（1，，false）
2. 基本类型与包装类型：基本类型有默认值，包装类型默认为null
3. 自动装箱与拆箱：基本类型与包装类型的互相转化
4. 浮点数运算精度丢失：与计算机保存浮点数的机制有关，通过BigDecimal解决

## 变量

1. 成员变量与局部变量
    - 成员变量定义于类，可被public，private，static等修饰符修饰，可被final修饰。被static修饰属于类，如没被赋初值会被自动赋值。没被static修饰属于对象。
    - 局部变量属于生效区间（代码块、方法等），不可被访问控制修饰符及static修饰，可被final修饰
2. 静态变量：被static修饰的变量，可被类所有实例共享。
3. 字符型常量与字符串常量

## 方法

1. 静态方法不能调用非静态成员
2. 重载与重写
    - 重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理
    - 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写
        - 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
        - 如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。
        - 构造方法无法被重写
3. 可变长参数：Java 的可变参数编译后实际会被转换成一个数组。允许在调用方法时传入不定长度的参数，0个或者多个参数。只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。

## 面向对象基础

1. 面向对象与面向过程
2. 创建一个对象：new运算符，new创建对象实例（对象实例在堆内存），对象引用指向对象实例（对象引用在栈内存）
3. 对象实例与对象引用
    - 一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）
    - 一个对象可以有 n 个引用指向它
4. 构造方法
    - 一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会添加默认的无参数的构造方法了。
    - 我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）
    - 如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。
    - 特点：
        - 名称与类名相同：构造方法的名称必须与类名完全一致
        - 没有返回值：构造方法没有返回类型，且不能使用 void 声明
        - 自动执行：在生成类的对象时，构造方法会自动执行，无需显式调用
        - 不能被重写（override），但可以被重载（overload）

5. 面向对象三大特征
    1. 封装：隐藏属性，开放方法
    2. 继承：使用已存在的类的定义作为基础建立新类。新类的定义可以增加新的数据或新的功能，也可以用父类的功能。
        - 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。
        - 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
        - 子类可以用自己的方式实现父类的方法。
    3. 多态：一个对象具有多种的状态，具体表现为父类的引用指向子类的实例
        - 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；
        - 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
        - 多态不能调用“只在子类存在但在父类不存在”的方法；
        - 如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。
6. 接口与抽象类
    1. 共同点
        - 实例化：接口和抽象类都不能直接实例化，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。
        - 抽象方法：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。
    2. 不同点
        - 设计目的：接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。
        - 继承和实现：一个类只能继承一个类（包括抽象类），因为 Java 不支持多继承。但一个类可以实现多个接口，一个接口也可以继承多个其他接口。
        - 成员变量：接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值。抽象类的成员变量可以有任何修饰符（private, protected, public），可以在子类中被重新定义或赋值。
        - 方法： 
            - Java 8 之前，接口中的方法默认是 public abstract ，也就是只能有方法声明。自 Java 8 起，可以在接口中定义 default（默认） 方法和 static （静态）方法。 自 Java 9 起，接口可以包含 private 方法。
            - 抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须在子类中实现。非抽象方法有具体实现，可以直接在抽象类中使用或在子类中重写。
7. 深拷贝与浅拷贝
    1. 浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
        - 实现了 Cloneable 接口，并重写了 clone() 方法
    2. 深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。
    3. 引用拷贝：两个不同的引用指向同一个对象

## Object

1. 定义：是一个特殊的类，是所有类的父类，主要提供了以下11个方法。
    - getClass()。native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写
    - hashCode()。用于返回对象的哈希码
    - equals(Object obj)。用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等
    - clone()。创建并返回当前对象的一份拷贝
    - toString()。返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法
    - notify()。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个
    - notifyAll()。唤醒在此对象监视器上等待的所有线程
    - wait(long timeout)。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
    - wait(long timeout, int nanos)。多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。
    - wait()。一直等待，没有超时时间
    - finalize()。实例被垃圾回收器回收的时候触发的操作
2. ==与equals()区别
    1. ==
        - 对于基本数据类型来说，== 比较的是值。
        - 对于引用数据类型来说，== 比较的是对象的内存地址。
    2. equals()
        - 类没有重写 equals()方法：通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 Object类equals()方法。
        - 类重写了 equals()方法：一般我们都重写 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。
3. hashCode()
    1. 作用：获取哈希码（int 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。
    2. 总结：
        - 如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。
        - 如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。
        - 如果两个对象的hashCode 值相等，并且equals()方法也返回 true，我们才认为这两个对象相等。
    3. 为什么重写 equals() 时必须重写 hashCode() 方法？
        - 因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。

## String

1. String、StringBuffer、StringBuilder 的区别？
    1. 可变性
        - String 是不可变的
        - StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法
    2. 线程安全性
        - String 中的对象是不可变的，也就可以理解为常量，线程安全
        - AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。
            - StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。
            - StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的
    3. 性能
        - 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。
        - StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。
        - 相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。
    4. 总结
        - 操作少量的数据: 适用 String
        - 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder
        - 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer
2. String为什么不可变？
    - String 类中使用 final 关键字修饰字符数组来保存字符串。
        - 被 final 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。
        - 因此，final 关键字修饰的数组保存字符串并不是 String 不可变的根本原因，因为这个数组保存的字符串是可变的（final 修饰引用类型变量的情况）(char是基本数据类型，但char[]不是)
    - 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。
    - String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。
3. 字符串拼接用“+” 还是 StringBuilder?
    - 用StringBuilder
4. String#equals() 和 Object#equals() 有何区别？
    - String 中的 equals 方法是被重写过的，比较的是 String 字符串的值是否相等。 Object 的 equals 方法是比较的对象的内存地址。
5. 字符串常量池的作用了解吗？
    - 字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。
6. String s1 = new String("abc");这句话创建了几个字符串对象？
    - 会创建 1 或 2 个字符串对象。
        - 字符串常量池中不存在 "abc"：会创建 2 个 字符串对象。一个在字符串常量池中，由 ldc 指令触发创建。一个在堆中，由 new String() 创建，并使用常量池中的 "abc" 进行初始化。
        - 字符串常量池中已存在 "abc"：会创建 1 个 字符串对象。该对象在堆中，由 new String() 创建，并使用常量池中的 "abc" 进行初始化。
7. String#intern 方法有什么作用?
    - intern() 方法的主要作用是确保字符串引用在常量池中的唯一性。
    - 当调用 intern() 时，如果常量池中已经存在相同内容的字符串，则返回常量池中已有对象的引用；否则，将该字符串添加到常量池并返回其引用。
8. String 类型的变量和常量做“+”运算时发生了什么？
    - 对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。
    - 在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 常量折叠(Constant Folding) 的代码优化。
    - 常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)
    - 并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：
        - 基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。
        - final 修饰的基本数据类型和字符串变量
        - 字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（<<、>>、>>> ）
    - 引用的值在程序编译期是无法确定的，编译器无法对其进行优化。
    - 对象引用和“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。
    - 字符串使用 final 关键字声明之后，可以让编译器当做常量来处理。被 final 关键字修饰之后的 String 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。

## 异常

1. Java异常类层次结构
    - Throwable
        - Exception：程序本身可以处理的异常，可以通过 catch 来进行捕获
            - Checked Exception：
                - 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。
                - 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常
                - 常见的有：IOException、ClassNotFoundException、SQLException、FileNotFoundException等
            - Unchecked Exception：
                - 不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。
                - RuntimeException及其子类统称为不受检查异常
                - 常见的有：NullPointerException(空指针错误)、IllegalArgumentException(参数错误比如方法入参类型错误)、NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）、ArrayIndexOutOfBoundsException（数组越界错误）、ClassCastException（类型转换错误）、ArithmeticException（算术错误）、SecurityException （安全错误比如权限不够）UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)等
        - Error：程序无法处理的错误，错误发生时，Java 虚拟机（JVM）一般会选择线程终止
2. Throwable 类常用方法
    1. String getMessage(): 返回异常发生时的详细信息
    2. String toString(): 返回异常发生时的简要描述。与直接放e一致。
    3. String getLocalizedMessage(): 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同
    4. void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息
3. try-catch-finally 如何使用？
    1. try块：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。
    2. catch块：用于处理 try 捕获到的异常。
    3. finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。
        - 不要在 finally 语句块中使用 return! 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。

4. finally 中的代码一定会执行吗？
    - 不一定的！在以下情况下，finally 中的代码不会被执行。
        1. finally 之前虚拟机被终止运行
        2. 程序所在的线程死亡。
        3. 关闭 CPU

5. 如何使用 try-with-resources 代替try-catch-finally？
    1. 适用范围（资源的定义）： 任何实现 java.lang.AutoCloseable或者 java.io.Closeable 的对象
    2. 关闭资源和 finally 块的执行顺序： 在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行
    3. Java 中类似于InputStream、OutputStream、Scanner、PrintWriter等的资源都需要我们调用close()方法来手动关闭。使用分号分隔，可以在try-with-resources块中声明多个资源。

## 泛型与通配符（面试指北

1. 定义与作用：Java 泛型（Generics） 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。
2. 使用方式
    1. 泛型类
        - T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
        - 在实例化泛型类时，必须指定T的具体类型
    2. 泛型接口
        - 实现泛型接口，不指定类型
        - 实现泛型接口，指定类型
    3. 泛型方法
        - public static < E > void printArray( E[] inputArray ) 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <E>
3. 应用场景
    1. 自定义接口通用返回结果 CommonResult<T> 通过参数 T 可根据具体的返回类型动态指定结果的数据类型
    2. 定义 Excel 处理类 ExcelUtil<T> 用于动态指定 Excel 导出的数据类型
    3. 构建集合工具类（参考 Collections 中的 sort, binarySearch 方法）

## 反射

1. 何谓反射？
    - 如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。
    - 反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。
    - 通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性
2. 反射的优缺点？
    - 优点：可以让我们的代码更加灵活、让我们在运行时有了分析操作类的能力、为各种框架提供开箱即用的功能提供了便利。
    - 缺点：增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点
3. 应用场景
    1. 框架
    2. 动态代理
    3. 注解
4. 获取Class对象的四种方式
    1. 知道具体类的情况下可以使用：Class alunbarClass = TargetObject.class;
    2. 通过 Class.forName()传入类的全路径获取：Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");
    3. 通过对象实例instance.getClass()获取：TargetObject o = new TargetObject(); Class alunbarClass2 = o.getClass();
    4. 通过类加载器xxxClassLoader.loadClass()传入类路径获取: ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject");
5. 反射的基本操作
    1. 创建一个我们要使用反射操作的类 TargetObject
    2. 使用反射操作这个类的方法以及属性
        1. 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例
        2. 获取 TargetObject 类中定义的所有方法
        3. 获取指定方法并调用
        4. 获取指定参数并对参数进行修改，为了对类中的参数进行修改我们取消安全检查
        5. 调用 private 方法，为了调用private方法我们取消安全检查

## 注解

1. 何谓注解？
    - Annotation （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。
    - 注解本质是一个继承了Annotation 的特殊接口
2. 解析方法
    1. 编译期直接扫描：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
    2. 运行期通过反射处理：像框架中自带的注解(比如 Spring 框架的 @Value、@Component)都是通过反射来进行处理的

## SPI（面试指南详解没看

1. 何谓 SPI?
    - SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”。专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。
    - SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。
2. 与API的区别
    - 一般模块之间都是通过接口进行通讯，因此我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。
    - 当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API。这种情况下，接口和实现都是放在实现方的包中。调用方通过接口调用实现方的功能，而不需要关心具体的实现细节。
    - 当接口存在于调用方这边时，这就是 SPI 。由接口调用方确定接口规则，然后由不同的厂商根据这个规则对这个接口进行实现，从而提供服务。
3. 优缺点
    1. 优点：大大地提高接口设计的灵活性
    2. 缺点：
        - 需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。
        - 当多个 ServiceLoader 同时 load 时，会有并发问题
4. 场景
    - SLF4J （Simple Logging Facade for Java）是 Java 的一个日志门面（接口），其具体实现有几种，比如：Logback、Log4j、Log4j2 等等，而且还可以切换。

## 序列化与反序列化

1. 定义
    1. 序列化：将数据结构或对象转换成可以存储或传输的形式，通常是二进制字节流，也可以是 JSON, XML 等文本格式
    2. 反序列化：将在序列化过程中所生成的数据转换为原始数据结构或者对象的过程
2. 场景
    1. 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；
    2. 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；
    3. 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；
    4. 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。
3. 序列化协议对应于 TCP/IP 4 层模型的哪一层？应用层
    1. TCP/IP 四层模型：应用层，传输层，网络层，网络接口层
    2. OSI七层模型：应用层、表示层、会话层，传输层，网络层，数据链路层，物理层
4. 如果有些字段不想进行序列化怎么办？
    - 对于不想进行序列化的变量，使用 transient 关键字修饰
    - transient 只能修饰变量，不能修饰类和方法。
    - transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。
    - static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化
5. JDK自带的序列化方式
    1. 只需实现 java.io.Serializable接口即可
    2. serialVersionUID 有什么作用？
        - 序列化号 serialVersionUID 属于版本控制的作用。
        - 反序列化时，会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 InvalidClassException 异常
        - 强烈推荐每个序列化类都手动指定其 serialVersionUID，如果不手动指定，那么编译器会动态生成默认的 serialVersionUID。
    3. serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？
        - static 修饰的变量是静态变量，属于类而非类的实例，本身是不会被序列化的。然而，serialVersionUID 是一个特例
    4. 比较常用的序列化协议：有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议

## IO

1. 定义：IO 即 Input/Output，输入和输出。
    - 数据输入到计算机内存的过程即输入
    - 反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。

## 语法糖（面试指南详解没看

1. 定义：语法糖（Syntactic sugar） 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。
    - 不过，JVM 其实并不能识别语法糖，Java 语法糖要想被正确执行，需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法
    - 这也侧面说明，Java 中真正支持语法糖的是 Java 编译器而不是 JVM。如果你去看com.sun.tools.javac.main.JavaCompiler的源码，你会发现在compile()中有一个步骤就是调用desugar()，这个方法就是负责解语法糖的实现的
    - 常用的语法糖主要有泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式等。

## Java值传递

1. 方法的定义可能会用到 参数（有参的方法），参数在程序语言中分为：
    - 实参（实际参数，Arguments）：用于传递给函数/方法的参数，必须有确定的值。
    - 形参（形式参数，Parameters）：用于定义函数/方法，接收实参，不需要有确定的值。
2. 程序设计语言将实参传递给方法（或函数）的方式分为两种：
    - 值传递：方法接收的是实参值的拷贝，会创建副本。
    - 引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。
3. Java只有值传递
    1. 传递基本类型参数，传递的就是基本类型的字面量值的拷贝，会创建副本
    2. 传递引用类型参数 ，传递的是实参的地址

## Java代理模式详解

1. 定义与作用
    - 代理模式是一种比较好理解的设计模式。简单来说就是 我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。
    - 代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作
2. 静态代理
    1. 对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦（需要对每个目标类都单独写一个代理类）。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。
    2. 从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。
    3. 步骤
        1. 定义一个接口及其实现类；
        2. 创建一个代理类同样实现这个接口
        3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。
3. 动态代理
    1. 更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( CGLIB 动态代理机制)
    2. 从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的
    3. 说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理
    4. 动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助
    5. 就 Java 来说，动态代理的实现方式有很多种，比如 JDK 动态代理、CGLIB 动态代理等
        1. JDK 动态代理
            1. 核心是InvocationHandler 接口和 Proxy 类
            2. 通过Proxy 类的 newProxyInstance() 创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler 接口的类的 invoke()方法。 你可以在 invoke() 方法中自定义处理逻辑，比如在方法执行前后做什么事情
            3. 步骤
                1. 定义一个接口及其实现类；
                2. 自定义 InvocationHandler 并重写invoke方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；
                3. 通过 Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h) 方法创建代理对象
        2. CGLIB动态代理机制
            1. CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理
            2. 核心是MethodInterceptor 接口和 Enhancer 类
            3. 可以通过 Enhancer类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 MethodInterceptor 中的 intercept 方法
            4. 步骤
                1. 定义一个类；
                2. 自定义 MethodInterceptor 并重写 intercept 方法，intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；
                3. 通过 Enhancer 类的 create()创建代理类
4. JDK 动态代理和 CGLIB 动态代理对比
    1. JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。
    2. 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显

## BigDecimal详解

1. 使用场景：BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。

## Java魔法类Unsafe（面试指南详解没看